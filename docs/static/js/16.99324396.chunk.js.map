{"version":3,"sources":["tensorflow/MnistData.ts","tensorflow/MnistTrain.tsx","tensorflow/index.tsx"],"names":["IMAGE_H","IMAGE_W","IMAGE_SIZE","NUM_CLASSES","loadImageData","Promise","resolve","img","Image","canvas","document","createElement","ctx","getContext","src","onload","width","naturalWidth","height","naturalHeight","datasetBytesBuffer","ArrayBuffer","NUM_DATASET_ELEMENTS","chunkSize","i","drawImage","imageData","getImageData","datasetBytesView","Uint8Array","j","length","data","res","slice","loadLabelData","a","fetch","then","r","arrayBuffer","labelsResponse","datasetLabels","MnistTrain","imageBoxRef","createRef","canvasRef","imageRef","lossChart","accuracyChart","model","images","labels","trainBatchCount","state","mnistDataPending","trainPending","trainEpoch","valAcc","valLoss","trainProgress","predictResult","loadMnistData","message","warning","setState","all","result","success","train","epochs","console","log","xs","tf","ys","totalNumBatches","Math","ceil","shape","fit","batchSize","validationSplit","callbacks","onBatchEnd","batch","logs","acc","loss","updateChart","testImagePredict","onEpochEnd","epoch","val_acc","val_loss","onTrainEnd","createConvModel","add","conv2d","inputShape","kernelSize","filters","activation","maxPooling2d","poolSize","strides","flatten","dense","units","compile","optimizer","metrics","summary","createDenseModel","range","count","reals","reduce","cur","item","output","predict","predictions","Array","from","argMax","dataSync","dispose","renderCanvas","canvasImg","current","drawCtx","image3d","fromPixels","image4d","resizeBilinear","as4D","prediction","maxIndex","fillRect","initCanvas","image","fillStyle","moused","addEventListener","e","toDataURL","beginPath","lineWidth","lineCap","strokeStyle","moveTo","offsetX","offsetY","lineTo","stroke","lossData","getData","changeData","accuracyData","renderChart","G2","container","autoFit","padding","line","position","point","size","style","scale","alias","axis","title","fontSize","fill","render","this","imageBox","innerHTML","real","div","className","ImageData","putImageData","pred","correct","innerText","appendChild","loading","type","onClick","danger","marginLeft","min","max","defaultValue","onChange","percent","steps","strokeColor","id","ref","alt","fontWeight","PureComponent","Tensorflowd"],"mappings":"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","file":"static/js/16.99324396.chunk.js","sourcesContent":["/**\r\n * 图片尺寸信息\r\n */\r\nexport const IMAGE_H = 28\r\nexport const IMAGE_W = 28\r\nexport const IMAGE_SIZE = IMAGE_H * IMAGE_W\r\n\r\n/**\r\n * 图片像素点数据\r\n * 宽 784 * 高 65000\r\n * 每一行的784个像素点 -> 28 * 28 的一张图片\r\n * \r\n * 每一个位置用三十二位浮点数存储红色通道的像素值，占用4个字节\r\n * Float32Array 用用三十二位浮点数存储\r\n * length = 65000 * 784 | byteLength = 65000 * 784 * 4\r\n */\r\n\r\nconst NUM_DATASET_ELEMENTS = 65000\r\nconst MNIST_IMAGES_SPRITE_PATH = './mnist_images.png'\r\n\r\n/**\r\n * 图片label数据\r\n * Uint8Array 用8位无符号整数存储\r\n * length = 65000 * 10 | byteLength = 65000 * 10\r\n * \r\n * 用每十个字节位来表示 0 ~ 9\r\n * 1000000000 => 0\r\n * 0100000000 => 1\r\n * 0100000001 => 9\r\n */\r\nexport const NUM_CLASSES = 10\r\nconst MNIST_LABELS_PATH = './mnist_labels_uint8'\r\n\r\n/**\r\n * 取前五万张\r\n */\r\nconst NUM_TRAIN_ELEMENTS = 50000\r\n\r\nexport function loadImageData(): Promise<Uint8Array> {\r\n  return new Promise((resolve) => {\r\n    const img = new Image()\r\n    const canvas = document.createElement('canvas')\r\n    const ctx = canvas.getContext('2d')!\r\n    img.src = MNIST_IMAGES_SPRITE_PATH\r\n    img.onload = () => {\r\n      img.width = img.naturalWidth\r\n      img.height = img.naturalHeight\r\n      const datasetBytesBuffer = new ArrayBuffer(NUM_DATASET_ELEMENTS * IMAGE_SIZE)\r\n      //一次裁剪5000高度的图片，以获取像素，避免内存泄露\r\n      const chunkSize = 5000\r\n      canvas.width = img.width\r\n      canvas.height = chunkSize\r\n      for (let i = 0; i < NUM_DATASET_ELEMENTS / chunkSize; i++) {\r\n        ctx.drawImage(img, 0, i * chunkSize, img.width, chunkSize, 0, 0, img.width, chunkSize)\r\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)\r\n        const datasetBytesView = new Uint8Array(\r\n          datasetBytesBuffer,\r\n          i * img.width * chunkSize,\r\n          img.width * chunkSize\r\n        )\r\n        for (let j = 0; j < datasetBytesView.length; j++) {\r\n          //只要红色通道\r\n          datasetBytesView[j] = imageData.data[j * 4]\r\n        }\r\n      }\r\n      const datasetImages = new Uint8Array(datasetBytesBuffer)\r\n      const res = datasetImages.slice(0, IMAGE_SIZE * NUM_TRAIN_ELEMENTS)\r\n      resolve(res)\r\n    }\r\n  })\r\n}\r\n\r\nexport function loadLabelData(): Promise<Uint8Array> {\r\n  return new Promise(async (resolve) => {\r\n    const labelsResponse = await fetch(MNIST_LABELS_PATH).then(r => r.arrayBuffer())\r\n    const datasetLabels = new Uint8Array(labelsResponse)\r\n    const res = datasetLabels.slice(0, NUM_CLASSES * NUM_TRAIN_ELEMENTS)\r\n    resolve(res)\r\n  })\r\n}","import { createRef, PureComponent } from 'react'\r\nimport * as tf from '@tensorflow/tfjs';\r\nimport { loadImageData, loadLabelData, IMAGE_SIZE, IMAGE_H, IMAGE_W, NUM_CLASSES } from './MnistData'\r\nimport * as G2 from '@antv/g2'\r\nimport { Button, message, InputNumber, Alert, Progress } from 'antd'\r\nimport './index.css'\r\n\r\nexport default class MnistTrain extends PureComponent {\r\n  imageBoxRef = createRef<HTMLDivElement>()\r\n  canvasRef = createRef<HTMLCanvasElement>()\r\n  imageRef = createRef<HTMLImageElement>()\r\n\r\n  lossChart: G2.Chart | null = null\r\n  accuracyChart: G2.Chart | null = null\r\n\r\n  model: tf.Sequential | null = null\r\n  images: Uint8Array | null = null\r\n  labels: Uint8Array | null = null\r\n\r\n  trainBatchCount: number = 0\r\n  state = {\r\n    mnistDataPending: false,\r\n    trainPending: false,\r\n    trainEpoch: 1,\r\n    valAcc: 0,\r\n    valLoss: 0,\r\n    trainProgress: 0,\r\n    predictResult: null\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.initCanvas()\r\n    this.renderChart()\r\n  }\r\n\r\n  loadMnistData = async () => {\r\n    if (this.images && this.labels) {\r\n      return message.warning('data is loaded!')\r\n    }\r\n    this.setState({ ...this.state, mnistDataPending: true })\r\n    const result = await Promise.all([loadImageData(), loadLabelData()])\r\n    this.images = result[0]\r\n    this.labels = result[1]\r\n    this.setState({ ...this.state, mnistDataPending: false })\r\n    return message.success('loading done!')\r\n  }\r\n\r\n  train = async () => {\r\n    if (!this.model) {\r\n      return message.warning('Model is not created!')\r\n    }\r\n    if (!this.images || !this.labels) {\r\n      return message.warning('Mnist data is not loaded!')\r\n    }\r\n    const epochs = this.state.trainEpoch\r\n    this.setState({ ...this.state, trainPending: true })\r\n    console.log('Training model...')\r\n    const model = this.model\r\n    const batchSize = 320\r\n    //遗留15%的训练数据进行验证，以监控训练期间的过度拟合\r\n    const validationSplit = 0.15\r\n    const xs = tf.tensor4d(\r\n      this.images,\r\n      [this.images.length / IMAGE_SIZE, IMAGE_H, IMAGE_W, 1]\r\n    )\r\n\r\n    const ys = tf.tensor2d(\r\n      this.labels, [this.labels.length / NUM_CLASSES, NUM_CLASSES]\r\n    )\r\n    //当前批次\r\n    let trainBatchCount = 0\r\n    //总批次\r\n    const totalNumBatches = Math.ceil(xs.shape[0] * (1 - validationSplit) / batchSize) * epochs\r\n    await model.fit(xs, ys, {\r\n      batchSize,\r\n      validationSplit,\r\n      epochs: epochs,\r\n      callbacks: {\r\n        onBatchEnd: async (batch, logs: any) => {\r\n          trainBatchCount++\r\n          const trainProgress = ~~((trainBatchCount / totalNumBatches * 100) * 100) / 100\r\n          this.setState({ trainProgress, valAcc: logs.acc, valLoss: logs.loss })\r\n          this.updateChart(logs.loss, logs.acc)\r\n          if (batch % 10 === 0) {\r\n            this.testImagePredict()\r\n          }\r\n          await tf.nextFrame()\r\n        },\r\n        onEpochEnd: async (epoch, logs: any) => {\r\n          console.log(\"Epoch: \" + epoch + \" Loss: \" + logs.loss)\r\n          this.setState({ valAcc: logs.val_acc, valLoss: logs.val_loss })\r\n          await tf.nextFrame()\r\n        },\r\n        onTrainEnd: () => {\r\n          console.log('Train done!')\r\n          this.setState({ ...this.state, trainPending: false })\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  createConvModel = () => {\r\n    if (this.model) {\r\n      return message.success('Model is created!')\r\n    }\r\n    const model = tf.sequential()\r\n    model.add(tf.layers.conv2d({\r\n      inputShape: [IMAGE_H, IMAGE_W, 1],\r\n      kernelSize: 3,\r\n      filters: 16,\r\n      activation: 'relu'\r\n    }))\r\n    model.add(tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }))\r\n    model.add(tf.layers.conv2d({ kernelSize: 3, filters: 32, activation: 'relu' }))\r\n    model.add(tf.layers.maxPooling2d({ poolSize: 2, strides: 2 }))\r\n    model.add(tf.layers.conv2d({ kernelSize: 3, filters: 32, activation: 'relu' }))\r\n    model.add(tf.layers.flatten({}))\r\n    model.add(tf.layers.dense({ units: 64, activation: 'relu' }))\r\n    model.add(tf.layers.dense({ units: 10, activation: 'softmax' }))\r\n    model.compile({ optimizer: 'rmsprop', loss: 'categoricalCrossentropy', metrics: ['accuracy'] })\r\n    model.summary()\r\n    this.model = model\r\n    message.success('Model create done!')\r\n  }\r\n\r\n  createDenseModel = () => {\r\n    if (this.model) {\r\n      return message.success('Model is created!')\r\n    }\r\n    const model = tf.sequential()\r\n    model.add(tf.layers.flatten({ inputShape: [IMAGE_H, IMAGE_W, 1] }))\r\n    model.add(tf.layers.dense({ units: 42, activation: 'relu' }))\r\n    model.add(tf.layers.dense({ units: 10, activation: 'softmax' }))\r\n    model.compile({ optimizer: 'rmsprop', loss: 'categoricalCrossentropy', metrics: ['accuracy'] })\r\n    model.summary()\r\n    this.model = model\r\n    message.success('Model create done!')\r\n  }\r\n\r\n  /**\r\n   * 测试预测图片结果\r\n   */\r\n  testImagePredict = () => {\r\n    if (!this.images || !this.labels || !this.model) return\r\n    //获取图片总张数\r\n    // console.log('Img total is ' + this.images.length / 784)\r\n    //渲染范围 0 ~ 100 总的范围 0 ~ (this.images.length / 784)\r\n    const range = [100, 200]\r\n    const count = range[1] - range[0]\r\n    //截取图片\r\n    const images = this.images.slice(IMAGE_SIZE * range[0], range[1] * IMAGE_SIZE)\r\n    const labels = this.labels.slice(NUM_CLASSES * range[0], range[1] * NUM_CLASSES)\r\n\r\n    // tensor4d ->  [n 28 28 1]\r\n    const xs = tf.tensor4d(images, [images.length / IMAGE_SIZE, IMAGE_H, IMAGE_W, 1])\r\n\r\n    //获取真实结果\r\n    const reals = labels.reduce<number[]>((cur, item, i) => item ? [...cur, i % 10] : cur, [])\r\n    //预测结果\r\n    const output = this.model.predict(xs) as tf.Tensor2D\r\n    const predictions = Array.from(output.argMax(1).dataSync())\r\n    //必须显式的销毁\r\n    xs.dispose()\r\n    output.dispose()\r\n    this.renderCanvas(images, count, predictions, reals)\r\n  }\r\n\r\n  renderCanvas(images: Uint8Array, count: number, predictions: number[], reals: number[]) {\r\n    const imageBox = this.imageBoxRef.current!\r\n    imageBox.innerHTML = ''\r\n    for (let i = 0; i < count; i++) {\r\n      const image = images.slice(i * 784, i * 784 + 784)\r\n      const prediction = predictions[i]\r\n      const real = reals[i]\r\n      const div = document.createElement('div')\r\n      div.className = 'pred-container'\r\n      const canvas = document.createElement('canvas')\r\n      canvas.className = 'prediction-canvas'\r\n      const [width, height] = [28, 28]\r\n      canvas.width = width\r\n      canvas.height = height\r\n      const ctx = canvas.getContext('2d')!\r\n      const imageData = new ImageData(width, height)\r\n      /**\r\n       * ImageData.prototype.Uint8ClampedArray: Uint8ClampedArray\r\n       * 是一个8位无符号整型数组，8个二进制位有256种变化\r\n       * 所以能存储的十进制数就是0 ~ 255\r\n       * \r\n       * 一张图片是 28X28，那么它就有 28X28 个像素点\r\n       * 每一个像素点需要四个数据来表示 =  R红 G绿 B蓝 A色彩空间\r\n       * \r\n       * 那么我们就需要 28 x 28 x 4 个字节来存储这张图片\r\n       * 也就是new ImageData(28, 28)自动创建的内存空间大小\r\n       */\r\n      for (let i = 0; i < height * width; i++) {\r\n        const j = i * 4\r\n        imageData.data[j + 0] = image[i]\r\n        imageData.data[j + 1] = image[i]\r\n        imageData.data[j + 2] = image[i]\r\n        imageData.data[j + 3] = 255\r\n      }\r\n      ctx.putImageData(imageData, 0, 0)\r\n      const pred = document.createElement('div')\r\n      const correct = prediction === real\r\n      pred.className = correct ? 'pred-correct' : 'pred-incorrect'\r\n      pred.innerText = `预测: ${prediction}`\r\n      div.appendChild(pred)\r\n      div.appendChild(canvas)\r\n      imageBox.appendChild(div)\r\n    }\r\n  }\r\n\r\n  predict = () => {\r\n    const canvasImg = this.imageRef.current!\r\n    const drawCtx = this.canvasRef.current!.getContext('2d')!\r\n    if (!this.model) {\r\n      return message.warning('Model is not created!')\r\n    }\r\n\r\n    //只要红色通道\r\n    const image3d = tf.browser.fromPixels(canvasImg, 1)\r\n    const resize = tf.image.resizeBilinear(image3d, [28, 28])\r\n    const image4d = resize.as4D(1, 28, 28, 1)\r\n\r\n    const prediction = this.model.predict(image4d) as tf.Tensor2D\r\n    const maxIndex = tf.argMax(prediction, 1).dataSync()\r\n    this.setState({ ...this.state, predictResult: maxIndex[0] })\r\n    drawCtx.fillRect(0, 0, 280, 280)\r\n  }\r\n\r\n  initCanvas = () => {\r\n    const canvas = this.canvasRef.current!\r\n    const image = this.imageRef.current!\r\n    canvas.width = 280\r\n    canvas.height = 280\r\n    const ctx = canvas.getContext('2d')!\r\n    ctx.fillStyle = 'black'\r\n    ctx.fillRect(0, 0, 280, 280)\r\n    let moused = false\r\n    canvas.addEventListener('mousedown', (e) => {\r\n      moused = true\r\n    })\r\n    canvas.addEventListener('mouseup', (e) => {\r\n      moused = false\r\n      image.src = canvas.toDataURL('image/png')\r\n    })\r\n    canvas.addEventListener('mousemove', (e) => {\r\n      if (!moused) return\r\n      ctx.beginPath()\r\n      ctx.lineWidth = 32\r\n      ctx.lineCap = 'round'\r\n      ctx.strokeStyle = 'white'\r\n      ctx.moveTo(e.offsetX, e.offsetY)\r\n      ctx.lineTo(e.offsetX, e.offsetY)\r\n      ctx.stroke()\r\n    })\r\n  }\r\n\r\n  updateChart = (loss: number, acc: number) => {\r\n    if (!this.lossChart || !this.accuracyChart) return\r\n    const batch = this.trainBatchCount++\r\n    const lossData = [\r\n      ...this.lossChart.getData(), { batch, loss }\r\n    ]\r\n    this.lossChart.changeData(lossData)\r\n    const accuracyData = [\r\n      ...this.accuracyChart.getData(), { batch, acc }\r\n    ]\r\n    this.accuracyChart.changeData(accuracyData)\r\n  }\r\n\r\n  renderChart = () => {\r\n    const lossData: { batch: number, loss: number }[] = [\r\n      // { batch: 0, loss: 1 }, { batch: 1, loss: 2 }, { batch: 2, loss: 1 }\r\n    ]\r\n    const lossChart = new G2.Chart({\r\n      container: 'lossChart',\r\n      autoFit: true,\r\n      height: 300,\r\n      padding: 50\r\n    })\r\n    lossChart.data(lossData)\r\n    lossChart.line().position('batch*loss')\r\n    lossChart.point().position('batch*loss').size(4).shape('circle').style({\r\n      stroke: '#fff',\r\n      lineWidth: 1\r\n    })\r\n    lossChart.scale('loss', {\r\n      alias: 'LOSS'\r\n    })\r\n    lossChart.axis('loss', {\r\n      title: { style: { fontSize: 16, fill: '#aaaaaa' } }\r\n    })\r\n    lossChart.scale('batch', {\r\n      alias: 'BATCH'\r\n    })\r\n    lossChart.axis('batch', {\r\n      title: { style: { fontSize: 16, fill: '#aaaaaa' } }\r\n    })\r\n    lossChart.render()\r\n    this.lossChart = lossChart\r\n\r\n    const accuracyChart = new G2.Chart({\r\n      container: 'accuracyChart',\r\n      autoFit: true,\r\n      height: 300,\r\n      padding: 50\r\n    })\r\n    const accuracyData: { batch: number, acc: number }[] = [\r\n      // { batch: 0, acc: 1 }, { batch: 1, acc: 2 }, { batch: 2, acc: 1 }\r\n    ]\r\n    accuracyChart.data(accuracyData)\r\n    accuracyChart.line().position('batch*acc').style({\r\n      stroke: '#facc15'\r\n    })\r\n    accuracyChart.point().position('batch*acc').size(4).shape('circle').style({\r\n      stroke: 'white',\r\n      lineWidth: 1,\r\n      fill: '#facc15'\r\n    })\r\n    accuracyChart.scale('acc', {\r\n      alias: 'ACCURACY'\r\n    })\r\n    accuracyChart.axis('acc', {\r\n      title: { style: { fontSize: 16, fill: '#aaaaaa' } }\r\n    })\r\n    accuracyChart.scale('batch', {\r\n      alias: 'BATCH'\r\n    })\r\n    accuracyChart.axis('batch', {\r\n      title: { style: { fontSize: 16, fill: '#aaaaaa' } }\r\n    })\r\n    accuracyChart.render()\r\n    this.accuracyChart = accuracyChart\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"tf\">\r\n        <div className=\"ftitle\">\r\n          TRAINING PARAMETERS\r\n        </div>\r\n        <div className=\"bt\">\r\n          <Button\r\n            loading={this.state.mnistDataPending}\r\n            type=\"primary\" size=\"large\"\r\n            onClick={this.loadMnistData}\r\n          >LOAD DATA</Button>\r\n          <Button\r\n            onClick={this.createConvModel}\r\n            type=\"primary\"\r\n            size=\"large\"\r\n          >CREATE MODEL</Button>\r\n          <Button\r\n            onClick={this.train}\r\n            size=\"large\"\r\n            danger\r\n            loading={this.state.trainPending}\r\n          >TRAIN MODEL</Button>\r\n          <span style={{ marginLeft: '10px' }}>EPOCHS</span>\r\n          <InputNumber\r\n            style={{ marginLeft: '10px' }}\r\n            min={1} max={3}\r\n            defaultValue={1}\r\n            size=\"large\"\r\n            onChange={(e) => {\r\n              if (typeof e === 'number') {\r\n                this.setState({ ...this.state, trainEpoch: e })\r\n              }\r\n            }}\r\n          />\r\n        </div>\r\n        <div className=\"ftitle\">\r\n          TRAINING PROGRESS\r\n        </div>\r\n        <div>\r\n          {this.state.valAcc ? <Alert\r\n            message={`精度：${this.state.valAcc}，误差：${this.state.valLoss}`}\r\n            type=\"success\"\r\n          /> : null}\r\n          <Progress percent={this.state.trainProgress} steps={30} strokeColor=\"#52c41a\" />\r\n        </div>\r\n        <div id=\"lossChart\"></div>\r\n        <div id=\"accuracyChart\"></div>\r\n        <div className=\"ftitle\">\r\n          INFERENCE EXAMPLES\r\n        </div>\r\n        <div ref={this.imageBoxRef} className=\"pred\"></div>\r\n        <div className=\"ftitle\">\r\n          TEST MODEL\r\n        </div>\r\n        <div className=\"bt\">\r\n          <Button size=\"large\" type=\"primary\" onClick={this.predict}>PREDICT</Button>\r\n        </div>\r\n        <div className=\"draw\">\r\n          <canvas ref={this.canvasRef}></canvas>\r\n          <img alt=\"\" ref={this.imageRef} style={{ width: 280, height: 280, marginLeft: '2px' }} />\r\n          <span style={{ fontSize: '80px', marginLeft: '30px', fontWeight: 600 }}>{this.state.predictResult}</span>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}","import MnistTrain from './MnistTrain'\r\n\r\nexport default function Tensorflowd() {\r\n  return(\r\n    <div>\r\n      <MnistTrain/>\r\n    </div>\r\n  )\r\n}"],"sourceRoot":""}